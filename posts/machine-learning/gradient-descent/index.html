<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>경사 하강법 (Gradient Descent) | Ganni Devlog</title>
<meta name="keywords" content="경사 하강법, 비용 함수" />
<meta name="description" content="머신러닝 그리고 딥러닝 모델 학습에서 가장 중요한 것은 실제 값과 예측 값의 차이를 최소화해 더 정확한 예측을 하는 것입니다. 경사 하강법은 이를 위한 방법으로 &lsquo;데이터를 기반으로 알고리즘이 스스로 학습한다&rsquo;는 머신러닝의 개념을 실현한 핵심 기법 중 하나입니다.
 비용 함수 (Cost Function) 아래 그림과 같이 주어진 X 에 대해 Y 를 예측하는 예측 함수, 다시 말해 가설 함수 Y = B0 &#43; B1*X를 구하는 상황을 생각해봅시다. 우리는 실제 관측치인 주황색 점과 가설 함수의 예측치 간의 차이(error)를 최소화하는 B0(절편)과 B1(기울기)를 알아야 합니다.">
<meta name="author" content="">
<link rel="canonical" href="https://koolganni.github.io/posts/machine-learning/gradient-descent/" />
<link crossorigin="anonymous" href="/assets/css/stylesheet.min.b15591da31b4f827d6dc0b97cf931d21b01610305321ac220bf755cf6aade94e.css" integrity="sha256-sVWR2jG0&#43;CfW3AuXz5MdIbAWEDBTIawiC/dVz2qt6U4=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.min.7680afc38aa6b15ddf158a4f3780b7b1f7dde7e91d26f073e6229bb7a0793c92.js" integrity="sha256-doCvw4qmsV3fFYpPN4C3sffd5&#43;kdJvBz5iKbt6B5PJI="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://koolganni.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://koolganni.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://koolganni.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://koolganni.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://koolganni.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<meta name="generator" content="Hugo 0.81.0" />
<meta property="og:title" content="경사 하강법 (Gradient Descent)" />
<meta property="og:description" content="머신러닝 그리고 딥러닝 모델 학습에서 가장 중요한 것은 실제 값과 예측 값의 차이를 최소화해 더 정확한 예측을 하는 것입니다. 경사 하강법은 이를 위한 방법으로 &lsquo;데이터를 기반으로 알고리즘이 스스로 학습한다&rsquo;는 머신러닝의 개념을 실현한 핵심 기법 중 하나입니다.
 비용 함수 (Cost Function) 아래 그림과 같이 주어진 X 에 대해 Y 를 예측하는 예측 함수, 다시 말해 가설 함수 Y = B0 &#43; B1*X를 구하는 상황을 생각해봅시다. 우리는 실제 관측치인 주황색 점과 가설 함수의 예측치 간의 차이(error)를 최소화하는 B0(절편)과 B1(기울기)를 알아야 합니다." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://koolganni.github.io/posts/machine-learning/gradient-descent/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2021-04-11T19:22:21&#43;09:00" />
<meta property="article:modified_time" content="2021-04-11T19:22:21&#43;09:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="경사 하강법 (Gradient Descent)"/>
<meta name="twitter:description" content="머신러닝 그리고 딥러닝 모델 학습에서 가장 중요한 것은 실제 값과 예측 값의 차이를 최소화해 더 정확한 예측을 하는 것입니다. 경사 하강법은 이를 위한 방법으로 &lsquo;데이터를 기반으로 알고리즘이 스스로 학습한다&rsquo;는 머신러닝의 개념을 실현한 핵심 기법 중 하나입니다.
 비용 함수 (Cost Function) 아래 그림과 같이 주어진 X 에 대해 Y 를 예측하는 예측 함수, 다시 말해 가설 함수 Y = B0 &#43; B1*X를 구하는 상황을 생각해봅시다. 우리는 실제 관측치인 주황색 점과 가설 함수의 예측치 간의 차이(error)를 최소화하는 B0(절편)과 B1(기울기)를 알아야 합니다."/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://koolganni.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "경사 하강법 (Gradient Descent)",
      "item": "https://koolganni.github.io/posts/machine-learning/gradient-descent/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "경사 하강법 (Gradient Descent)",
  "name": "경사 하강법 (Gradient Descent)",
  "description": "머신러닝 그리고 딥러닝 모델 학습에서 가장 중요한 것은 실제 값과 예측 값의 차이를 최소화해 더 정확한 예측을 하는 것입니다. 경사 하강법은 이를 위한 방법으로 \u0026lsquo;데이터를 기반으로 알고리즘이 스스로 학습한다\u0026rsquo;는 머신러닝의 개념을 실현한 핵심 기법 중 하나입니다.\n 비용 함수 (Cost Function) 아래 그림과 같이 주어진 X 에 대해 Y 를 예측하는 예측 함수, 다시 말해 가설 함수 Y = B0 + B1*X를 구하는 상황을 생각해봅시다. 우리는 실제 관측치인 주황색 점과 가설 함수의 예측치 간의 차이(error)를 최소화하는 B0(절편)과 B1(기울기)를 알아야 합니다.",
  "keywords": [
    "경사 하강법", "비용 함수"
  ],
  "articleBody": " 머신러닝 그리고 딥러닝 모델 학습에서 가장 중요한 것은 실제 값과 예측 값의 차이를 최소화해 더 정확한 예측을 하는 것입니다. 경사 하강법은 이를 위한 방법으로 ‘데이터를 기반으로 알고리즘이 스스로 학습한다’는 머신러닝의 개념을 실현한 핵심 기법 중 하나입니다.\n 비용 함수 (Cost Function) 아래 그림과 같이 주어진 X 에 대해 Y 를 예측하는 예측 함수, 다시 말해 가설 함수 Y = B0 + B1*X를 구하는 상황을 생각해봅시다. 우리는 실제 관측치인 주황색 점과 가설 함수의 예측치 간의 차이(error)를 최소화하는 B0(절편)과 B1(기울기)를 알아야 합니다. 이때 비용 함수(Cost Function)라는 지표를 활용합니다.\n비용 함수는 임의의 함수를 사용할 수도 있지만 일반적으로는 평균 제곱 오차(MSE)와 교차 엔트로피 오차(CEE)를 사용합니다. 이번 글에서는 평균 제곱 오차를 기준으로 살펴보겠습니다.\n위에서 살펴본 B 값을 앞으로는 θ 값으로 바꿔 이야기해보겠습니다. 가설 함수 h(x) 의 값은 정해진 변수 𝑥 값 외에 미지의 θ 값에 의해 결정됩니다.\n우리의 목적은 비용 함수, 즉 실제 값과 예측 값의 차이를 최소화(minimize) 하는 θ 값을 찾는 것입니다. 이때 경사 하강법(Gradient Descent)을 사용합니다.\n 경사 하강법 (Gradient Descent) 위에서 살펴본 비용 함수를 그래프로 나타내면 아래와 같이 포물선 형태의 2차 함수를 확인할 수 있습니다. 그리고 θ 값 다시 말해 Weight 값에 따라 비용 함수의 값이 달라지는 것을 볼 수 있습니다.\n비용 함수의 값이 최소인 부분이자 실제 값과 예측 값의 차이가 최소인 부분으로 다가갈수록 2차 함수인 비용 함수를 미분한 값, 즉 1차 함수의 기울기(Gradient) 가 0에 가까워짐을 알 수 있습니다.\n경사 하강법은 이처럼 초기 Weight 에서부터 미분을 적용해 이 미분한 값, 즉 기울기가 계속 감소하는 방향으로 Weight 를 업데이트합니다. 그리고 이 기울기가 더 이상 감소하지 않는 지점을 우리가 찾고자 하는 비용 함수가 최소인 지점으로 간주합니다.\n경사 하강법의 계산 과정을 수식으로 간단히 살펴보겠습니다.   Update rules : ɑ 와 ‘비용 함수를 θ 로 미분한 값’을 곱한 값으로 θ 값을 업데이트합니다.\n ɑ : 학습률(Learning rate) 값을 의미하며 θ 값을 얼마나 업데이트할지 결정합니다. ɑ 가 너무 크면 θ 값이 큰 값으로 발산해버릴 수 있고 반대로 너무 작다면 최적의 θ 값을 찾을 때까지 시간이 너무 오래 걸리거나 찾지 못할 수 있습니다.    Derivatives : 비용 함수를 θ 로 미분한 결과입니다.\n 연쇄 법칙(Chain Rule)을 활용하면 쉽게 계산할 수 있습니다.     Local Minimum 과 Global Minimum 경사 하강법은 기울기를 기준으로 비용 함수가 최소가 되는 지점을 찾는다고 이야기 했습니다. 하지만 해당 지점이 항상 최솟값이라는 보장을 할 수 있을까요?\n위에서 살펴본 선형 회귀를 위한 MSE 비용 함수의 경우 볼록 함수(Convex Function)로 초기 Weight 가 어디에서 시작하는지 상관없이 단 하나의 최솟값을 찾게 됩니다.\n하지만 주어진 𝑥 다시 말해 Feature 의 개수가 늘어난다면 비용 함수는 아래와 같이 비볼록 함수(Non-convex Function)가 될 것입니다.\n비볼록 함수는 시작 위치에 따라 다른 지점을 찾기 때문에 전역 최솟값(Global Minimum)을 찾지 못하고 지역 최솟값(Local Minimum)에 빠질 위험이 있습니다. 사실 우리가 마주칠 대부분의 문제는 이러한 비볼록 함수이므로 단순한 경사 하강법으로는 한계가 있습니다.\n이를 해결하기 위한 방법 중 하나로 기울기에 관성을 부과한 모멘텀(Momentum)이라는 방법이 있습니다. 자세한 내용은 다음 글에서 알아보겠습니다.\n References  https://youtu.be/TxIVr-nk1so https://www.boostcourse.org/ai222/lecture/24509 밑바닥부터 시작하는 딥러닝 1 - 한빛미디어 (2017)  ",
  "wordCount" : "455",
  "inLanguage": "en",
  "datePublished": "2021-04-11T19:22:21+09:00",
  "dateModified": "2021-04-11T19:22:21+09:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://koolganni.github.io/posts/machine-learning/gradient-descent/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Ganni Devlog",
    "logo": {
      "@type": "ImageObject",
      "url": "https://koolganni.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>
<noscript>
    <style type="text/css">
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: #1d1e20;
                --entry: #2e2e33;
                --primary: rgba(255, 255, 255, 0.84);
                --secondary: rgba(255, 255, 255, 0.56);
                --tertiary: rgba(255, 255, 255, 0.16);
                --content: rgba(255, 255, 255, 0.74);
                --hljs-bg: #2e2e33;
                --code-bg: #37383e;
                --border: #333;
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://koolganni.github.io/" accesskey="h" title="Ganni Devlog (Alt + H)">Ganni Devlog</a>
            <span class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </span>
        </div>
        <ul id="menu" onscroll="menu_on_scroll()">
            <li>
                <a href="https://koolganni.github.io/categories/" title="Categories">
                    <span>Categories</span>
                </a>
            </li>
            <li>
                <a href="https://koolganni.github.io/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      경사 하강법 (Gradient Descent)
    </h1>
    <div class="post-meta">April 11, 2021
</div>
  </header> 
  <div class="post-content"><blockquote>
<p>머신러닝 그리고 딥러닝 모델 학습에서 가장 중요한 것은 실제 값과 예측 값의 차이를 최소화해 더 정확한 예측을 하는 것입니다. <code>경사 하강법</code>은 이를 위한 방법으로 &lsquo;데이터를 기반으로 알고리즘이 스스로 학습한다&rsquo;는 머신러닝의 개념을 실현한 핵심 기법 중 하나입니다.</p>
</blockquote>
<h3 id="비용-함수-cost-function">비용 함수 (Cost Function)<a hidden class="anchor" aria-hidden="true" href="#비용-함수-cost-function">#</a></h3>
<p>아래 그림과 같이 주어진 X 에 대해 Y 를 예측하는 예측 함수, 다시 말해 가설 함수 <code>Y = B0 + B1*X</code>를 구하는 상황을 생각해봅시다. 우리는 실제 관측치인 주황색 점과 가설 함수의 예측치 간의 차이(error)를 최소화하는 B0(절편)과 B1(기울기)를 알아야 합니다. 이때 <code>비용 함수(Cost Function)</code>라는 지표를 활용합니다.</p>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/76609403/117820272-5926e000-b2a5-11eb-8bfb-a80638bd57ba.png" alt="image"  />
</p>
<p><code>비용 함수</code>는 임의의 함수를 사용할 수도 있지만 일반적으로는 평균 제곱 오차(MSE)와 교차 엔트로피 오차(CEE)를 사용합니다. 이번 글에서는 평균 제곱 오차를 기준으로 살펴보겠습니다.</p>
<p>위에서 살펴본 B 값을 앞으로는 θ 값으로 바꿔 이야기해보겠습니다. 가설 함수 h(x) 의 값은 정해진 변수 𝑥 값 외에 미지의 θ 값에 의해 결정됩니다.</p>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/76609403/117820895-f5e97d80-b2a5-11eb-89bf-1b4b0da042db.png" alt="image"  />
</p>
<p>우리의 목적은 <code>비용 함수</code>, 즉 실제 값과 예측 값의 차이를 <strong>최소화(minimize)</strong> 하는 θ 값을 찾는 것입니다. 이때 <code>경사 하강법(Gradient Descent)</code>을 사용합니다.</p>
<hr>
<h3 id="경사-하강법-gradient-descent">경사 하강법 (Gradient Descent)<a hidden class="anchor" aria-hidden="true" href="#경사-하강법-gradient-descent">#</a></h3>
<p>위에서 살펴본 <code>비용 함수</code>를 그래프로 나타내면 아래와 같이 포물선 형태의 2차 함수를 확인할 수 있습니다. 그리고 θ 값 다시 말해 Weight 값에 따라 <code>비용 함수</code>의 값이 달라지는 것을 볼 수 있습니다.</p>
<p><code>비용 함수</code>의 값이 최소인 부분이자 실제 값과 예측 값의 차이가 최소인 부분으로 다가갈수록 2차 함수인 <code>비용 함수</code>를 <strong>미분</strong>한 값, 즉 1차 함수의 <strong>기울기(Gradient)</strong> 가 0에 가까워짐을 알 수 있습니다.</p>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/76609403/117825872-a35e9000-b2aa-11eb-9b30-49139db9dc7b.png" alt="image"  />
</p>
<p><code>경사 하강법</code>은 이처럼 초기 Weight 에서부터 미분을 적용해 이 미분한 값, 즉 <strong>기울기가 계속 감소하는 방향</strong>으로 Weight 를 업데이트합니다. 그리고 이 기울기가 더 이상 감소하지 않는 지점을 우리가 찾고자 하는 <code>비용 함수</code>가 최소인 지점으로 간주합니다.</p>
<h4 id="경사-하강법의-계산-과정을-수식으로-간단히-살펴보겠습니다">경사 하강법의 계산 과정을 수식으로 간단히 살펴보겠습니다.<a hidden class="anchor" aria-hidden="true" href="#경사-하강법의-계산-과정을-수식으로-간단히-살펴보겠습니다">#</a></h4>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/76609403/117838088-f9d0cc00-b2b4-11eb-92c9-5a01cd4fcabe.png" alt="image"  />
</p>
<ul>
<li>
<p><strong>Update rules :</strong> ɑ 와 &lsquo;비용 함수를 θ 로 미분한 값&rsquo;을 곱한 값으로 θ 값을 업데이트합니다.</p>
<ul>
<li>ɑ : 학습률(Learning rate) 값을 의미하며 θ 값을 얼마나 업데이트할지 결정합니다.</li>
<li>ɑ 가 너무 크면 θ 값이 큰 값으로 발산해버릴 수 있고 반대로 너무 작다면 최적의 θ 값을 찾을 때까지 시간이 너무 오래 걸리거나 찾지 못할 수 있습니다.</li>
</ul>
</li>
<li>
<p><strong>Derivatives :</strong> 비용 함수를 θ 로 미분한 결과입니다.</p>
<ul>
<li>연쇄 법칙(Chain Rule)을 활용하면 쉽게 계산할 수 있습니다.</li>
</ul>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/76609403/117846692-a2365e80-b2bc-11eb-8d87-3efb9d19269e.jpeg" alt="IMG_E1C0F6F5ABDC-1"  />
</p>
</li>
</ul>
<hr>
<h3 id="local-minimum-과-global-minimum">Local Minimum 과 Global Minimum<a hidden class="anchor" aria-hidden="true" href="#local-minimum-과-global-minimum">#</a></h3>
<p><code>경사 하강법</code>은 기울기를 기준으로 <code>비용 함수</code>가 최소가 되는 지점을 찾는다고 이야기 했습니다. 하지만 해당 지점이 항상 최솟값이라는 보장을 할 수 있을까요?</p>
<p>위에서 살펴본 선형 회귀를 위한 MSE <code>비용 함수</code>의 경우 <code>볼록 함수(Convex Function)</code>로 초기 Weight 가 어디에서 시작하는지 상관없이 단 <strong>하나</strong>의 최솟값을 찾게 됩니다.</p>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/76609403/117993043-5944df80-b37a-11eb-91a2-10caddd81920.png" alt="image"  />
</p>
<p>하지만 주어진 𝑥 다시 말해 Feature 의 개수가 늘어난다면 <code>비용 함수</code>는 아래와 같이 <code>비볼록 함수(Non-convex Function)</code>가 될 것입니다.</p>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/76609403/117993182-75e11780-b37a-11eb-8f4f-7f62dc4ce8bb.png" alt="image"  />
</p>
<p><code>비볼록 함수</code>는 <strong>시작 위치</strong>에 따라 다른 지점을 찾기 때문에 <code>전역 최솟값(Global Minimum)</code>을 찾지 못하고 <code>지역 최솟값(Local Minimum)</code>에 빠질 위험이 있습니다. 사실 우리가 마주칠 대부분의 문제는 이러한 <code>비볼록 함수</code>이므로 단순한 <code>경사 하강법</code>으로는 한계가 있습니다.</p>
<p><img loading="lazy" src="https://user-images.githubusercontent.com/76609403/117997404-e2a9e100-b37d-11eb-869d-85c62b9657e6.png" alt="image"  />
</p>
<p>이를 해결하기 위한 방법 중 하나로 기울기에 관성을 부과한 모멘텀(Momentum)이라는 방법이 있습니다. 자세한 내용은 다음 글에서 알아보겠습니다.</p>
<hr>
<h3 id="references">References<a hidden class="anchor" aria-hidden="true" href="#references">#</a></h3>
<ul>
<li><a href="https://youtu.be/TxIVr-nk1so">https://youtu.be/TxIVr-nk1so</a></li>
<li><a href="https://www.boostcourse.org/ai222/lecture/24509">https://www.boostcourse.org/ai222/lecture/24509</a></li>
<li>밑바닥부터 시작하는 딥러닝 1 - 한빛미디어 (2017)</li>
</ul>

</div>
  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://koolganni.github.io/tags/%EA%B2%BD%EC%82%AC-%ED%95%98%EA%B0%95%EB%B2%95/">경사 하강법</a></li>
      <li><a href="https://koolganni.github.io/tags/%EB%B9%84%EC%9A%A9-%ED%95%A8%EC%88%98/">비용 함수</a></li>
    </ul>
  </footer>
</article>
    </main>
    <footer class="footer">
    <span>&copy; 2021 <a href="https://koolganni.github.io/">Ganni Devlog</a></span>
    <span>&middot;</span>
    <span>Powered by <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a></span>
    <span>&middot;</span>
    <span>Theme <a href="https://git.io/hugopapermod" rel="noopener" target="_blank">PaperMod</a></span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)">
    <button class="top-link" id="top-link" type="button" accesskey="g">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
            <path d="M12 6H0l6-6z" />
        </svg>
    </button>
</a>

<script>
    window.onload = function () {
        if (localStorage.getItem("menu-scroll-position")) {
            document.getElementById('menu').scrollLeft = localStorage.getItem("menu-scroll-position");
        }
    }

    function menu_on_scroll() {
        localStorage.setItem("menu-scroll-position", document.getElementById('menu').scrollLeft);
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
<script>
    document.querySelectorAll('pre > code').forEach((codeblock) => {
        const container = codeblock.parentNode.parentNode;

        const copybutton = document.createElement('button');
        copybutton.classList.add('copy-code');
        copybutton.innerText = 'copy';

        function copyingDone() {
            copybutton.innerText = 'copied!';
            setTimeout(() => {
                copybutton.innerText = 'copy';
            }, 2000);
        }

        copybutton.addEventListener('click', (cb) => {
            if ('clipboard' in navigator) {
                navigator.clipboard.writeText(codeblock.textContent);
                copyingDone();
                return;
            }

            const range = document.createRange();
            range.selectNodeContents(codeblock);
            const selection = window.getSelection();
            selection.removeAllRanges();
            selection.addRange(range);
            try {
                document.execCommand('copy');
                copyingDone();
            } catch (e) { };
            selection.removeRange(range);
        });

        container.appendChild(copybutton);
    });
</script>
</body>

</html>
